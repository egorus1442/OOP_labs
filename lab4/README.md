тут немного по-другому сделал, в своей лабе я пихал все в .h, он поворчал, но принял

здесь я старался как можно больше запихнуть в .cpp, хотя и немного некрасиво получилось

как по мне, лучше все-таки в .h работать ¯\\_(ツ)_/¯

# вопросы
только про умные указатели спросил

**Умные указатели** — это объекты, которые управляют временем жизни динамически выделенных объектов в памяти. Они автоматически освобождают память, когда она больше не нужна, что помогает избежать утечек памяти и ошибок, связанных с неправильным управлением ресурсами.

В языке C++ умные указатели реализованы в стандартной библиотеке (начиная с C++11) и предоставляют удобный интерфейс для работы с динамической памятью. Основные виды умных указателей:

### 1. `std::unique_ptr`
`std::unique_ptr` — это умный указатель, который владеет объектом единолично. Это означает, что только один `unique_ptr` может владеть данным объектом в любой момент времени. Когда `unique_ptr` выходит из области видимости или явно уничтожается, объект, на который он указывает, автоматически освобождается.

Основные свойства:
- **Единоличное владение**: нельзя копировать `unique_ptr`, но можно перемещать (с помощью `std::move`).
- **Автоматическое освобождение памяти**: объект удаляется, когда указатель выходит из области видимости.

Пример:
```cpp
#include <memory>
#include <iostream>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl;  // Вывод: 10
    // Память автоматически освобождается, когда ptr выходит из области видимости
}
```

### 2. `std::shared_ptr`
`std::shared_ptr` — это умный указатель, который поддерживает **разделяемое владение** объектом. Несколько `shared_ptr` могут указывать на один и тот же объект, и объект будет удален только тогда, когда последний `shared_ptr`, указывающий на него, будет уничтожен.

Основные свойства:
- **Разделяемое владение**: несколько указателей могут владеть одним объектом.
- **Подсчет ссылок**: `shared_ptr` использует счетчик ссылок, чтобы отслеживать, сколько указателей ссылаются на объект. Когда счетчик становится равным нулю, объект удаляется.

Пример:
```cpp
#include <memory>
#include <iostream>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;  // Теперь ptr1 и ptr2 разделяют владение объектом
    std::cout << *ptr1 << std::endl;   // Вывод: 20
    std::cout << *ptr2 << std::endl;   // Вывод: 20
    // Память будет освобождена, когда оба указателя выйдут из области видимости
}
```

### 3. `std::weak_ptr`
`std::weak_ptr` — это умный указатель, который не влияет на время жизни объекта. Он используется совместно с `shared_ptr` для создания слабых ссылок на объект, чтобы избежать циклических зависимостей (когда два объекта ссылаются друг на друга через `shared_ptr`, что может привести к утечке памяти).

Основные свойства:
- **Слабая ссылка**: `weak_ptr` не увеличивает счетчик ссылок на объект.
- **Используется для избежания циклических зависимостей**.
- Чтобы получить доступ к объекту, на который указывает `weak_ptr`, нужно использовать метод `lock()`, который возвращает `shared_ptr`.

Пример:
```cpp
#include <memory>
#include <iostream>

int main() {
    std::shared_ptr<int> sharedPtr = std::make_shared<int>(30);
    std::weak_ptr<int> weakPtr = sharedPtr;  // Слабая ссылка на объект

    if (auto lockedPtr = weakPtr.lock()) {  // Проверяем, существует ли объект
        std::cout << *lockedPtr << std::endl;  // Вывод: 30
    } else {
        std::cout << "Объект уже удален" << std::endl;
    }
}
```

### Преимущества умных указателей:
1. **Автоматическое управление памятью**: Умные указатели автоматически освобождают память, что помогает избежать утечек памяти.
2. **Безопасность**: Умные указатели уменьшают вероятность ошибок, связанных с использованием "висячих" указателей (указателей на уже освобожденную память).
3. **Удобство**: Умные указатели облегчают работу с динамической памятью, устраняя необходимость явного вызова `delete`.

### Недостатки:
1. **Небольшие накладные расходы**: Использование `shared_ptr` и `weak_ptr` требует дополнительной памяти для хранения счетчика ссылок.
2. **Циклические зависимости**: При неправильном использовании `shared_ptr` могут возникнуть циклические зависимости, которые приведут к утечкам памяти. Для решения этой проблемы используется `weak_ptr`.

### Заключение
Умные указатели — это мощный инструмент для управления динамической памятью в C++. Они помогают избежать утечек памяти и делают код более безопасным и читаемым.